:PROPETIES:
:ID:       00ddd8f8-ca34-4ed4-941c-4de6d8ea90b6
:END:
#+title: Database

* Лекция 1
** Введение
ИС - это программно апаратный комплекс обеспечивающий выполнение следующиех функций:

1) Надёжное хранение информации в памяти компьютера
2) Выполение специфических преобразований информации и вычислений
3) Представление пользователям удобного интерфейса
Примеры ИС:
- Система бронирования
- Банковская система
- Покупка билетов
- Заказ такси

Банк данных - это разновидность ИС в которой реализованы функции центролизованного хранения и накопления обрабатываемой информации.
Организованной в одну или несколько БД.

** Компоненты банка данных
1) База данных - это совокупность специальным образом организованных данных хранящихся в памяти вычислительной системы и отражающих
состояние объектов и их взаимосвязей в расматриваемой предметной области.
2) Система управления БД и СУБД 
3) Приложение
4) Словарь данных
5) Администратор БД
6) Вычислительная система
7) Обслуживающий персонал 

** Модель представления данных
Модель представления данных - это логическая структура хранимой в БД информации
Основные модели данных:
- Иерархическая или древовидная
- Сетевая
- Реляционная
- Постреалиционная
- Многомерная
- Объектно-ориентированная

СУБД(Система управления базами данных) - это комплекс языковых и программных средств предназначенных для создания, ведения и совместного 
использования БД многими пользователями.

Приложения - это программа или комплекс программ обеспечивающих автоматизацию обработки информации для прикладной задачи

Словарь данных - это подсистема банка данных предназначеная для централизованного хранения информации о структурах данных взаимосвязях файлов
о типах файлов, данных, о форматах их представления, пренадлежнасти данных пользователям, кодам защиты и разграничения доступа

Администратор БД - это лицо или группа лиц отвечающая за выбор требований к БД её проектирование создание эффективное использование и 
сопровождение.

Вычислительная система - это совокупность взаимосвязанных и согласованно действующих ЭВМ. процессоров и других устройств обеспечивающих 
автоматизацию процессов приема обработки и выдачи информации потребителю.

Обслуживающий персонал - это лицо или группа лиц которая выполняет функции поддержания работы в технических и программных средств.

Виды банков данных:
1) По архитектуре вычеслительной среды (централизованные и распределённые)
2) По языку общение пользователя с БД (открытые и закрытые)
- Открытые с базовам языком
- Закрытые с собственных языком
  
* Лекция 2
** Основные функции и типовая организация современных СУБД
Основные функции СУБД:
1) Упровление данными во внешней памяти
2) Упровление буферами оперативной памяти
   В развитых СУБД поддерживается собственный набор буферов оперативной памяти, с собстной дисцеплиной
   замены буферов.
3) Управление транзакциями
   *Транзация* - это последовательность операций над БД рассматриваемых СУБД как единое целое.
   Либо транзация успешно выполняется и СУБД фиксирует изменения в БД произведенная этой транзакцией во внешней
   памяти, либо ни одно из этих изменений никак не отражается на состоянии БД.
   *План* (cпособ) выполнения набора транзакций называется сериальным, если рузультат совместного выполнения транзаций
   эквивалентен рузультату некоторого последовательного их выполнения.
   *Сериализация транзаций* - это механизм выполения транзакций по некоторому сериальному плану.
4) Журнализация изменений БД
   Под надежность хранения понимается то что СУБД должна быть в состоянии восстановить последнее согласованное
   состояние БД после любого аппаратного или программного или программного сбоя (мягкие и жесткие сбои).
   *Журнал* - это особая часть БД, недоступная пользователям СУБД и поддерживаемая с особой тщательностью, в
   которую поступают записи обо всех изменениях основной части БД.
5) Поддержка языков БД
   Стандартным языком наиболее распраненные реляционных СУБД является язык SQL (Structured Query Language)
   Язык базы данных:
   - DDL(Data Definition Languege) - язык определения структуры БД
   - DML(Data Monipulation Languege) - Набор операций для манипулирования информацией.
   
** Типовая организация современной СУБД
- *Ядро СУБД* (Data Base Engine)
  Отвечает за упровление данными во внешней памяти, упровление буферами оперативной памяти, управление транзацкциями
  и журнализацию
  Соответственно, можно выделить такие компоненты ядра как
  - менеджер данных;
  - менеджер буферов;
  - менеджер транзакций;
  - менеджер журнала;
- *Компилятор языка*
  Основной функцией компилятора языка БД является компиляция операторов языка БД в некоторую выполняемую программу.
  Результатом компиляции является выполняемая программа, представляемая в некоторых системах в машинных кодах,
  но более часто в выполняемом внутреннем машинно-независимом коде. 
- *Подсистема поддержки времени выполнения*
  В последнем случае реальное выполнение оператора производится с привлечением подсистемы поддержки времени выполнения,
  пред-ставляющей собой интерпретатор
  этого внутреннего языка.
- *Набор утилит*
  Наконец, в отдельные утилиты БД обычно выделяют такие
  процедуры, которые слишком накладно выполнять с использованием языка БД, например, загрузка и выгрузка БД,
  сбор статистики, глобальная проверка целостно-сти БД и т.д. Утилиты программируются с использованием интерфейса ядра СУБД, а иногда даже с проникновением внутрь ядра.
  
** Ранние подходы к оранизации СУБД
Хранимые в базе данные имеют определенную логическую структуру, т. е. описываются некоторой моделью представления данных, поддерживаемой СУБД.
К числу классических относятся следующие модели данных:
• иерархическая;
• сетевая;
• реляционная.
Кроме того, в последнее время появились и стали больше
использоваться в практике следующие модели данных: пост-реляционная, многомерная, объектно-ориентированная

*Ранние системы*
- Основанные на инветировананных списках;
- Иерархические системы;
- сетевые системы.

*Основанные на инветировананных списках.*
Данный вид СУБД отличается *преимуществами:* простотой организации БД и наличием весьма удобных языков манипулирования данными.
Однако такие СУБД обладают рядом *недостатков* на количество файлов для хранения данных, количество связей между ними, длину записи и количество ее полей.
К числу наиболее известных и типичных представителей таких систем относятся Datacom/DB компании Applied Data Research, Inc. (ADR), ориентированная на
использование на машинах основного класса фирмы IBM, и Adabas компании Software AG.

Структуры данных: Для БД, организованнаой с помощью инвертированных списков, характерно то, что хранимые таблицы и пути доступа к ним видны пользователям.
При этом:
1.  строки таблиц упорядочены системой в некоторой физической последова-тельности
2.  физическая упорядоченность строк всех таблиц может определяться и для всей БД
3.  для каждой таблицы можно определить произвольное число ключей поиска, для которых строятся индексы

*Манипулирование данными*
Поддерживаются два класса операторов:
1) операторы, устанавливающие адрес записи;
2) операторы над адресуемыми записями.

*Ограничения целостности*
Общие правила определения целостности БД отсутствуют.
В некоторых системах поддерживаются ограничения уникальности значений некоторых полей, но в основном все возлагается на прикладную программу.

*Иерархические системы (древовидный):*
Типичным представителем иерархической системы является Information Management System (IMS) фирмы ІВМ.
pp*Структуры данных:*
Иерархическая БД состоит из упорядоченного набора деревьев, точнее, из упорядоченного набора нескольких экземпляров одного типа дерева.
Тип дерева состоит из одного «корневого» типа записи и упорядоченного набора из нуля или более типов поддеревьев (каждое из кото-рых
является некоторым типом дерева). Тип дерева в целом представляет собой иерархически организованный набор типов записи.

Между деревьями существуют связи , такие, что родитель может иметь несколько потомков, но один потомок только одиного родителя.

*Манипулирование данными:*
Примерами типичных операторов манипулирования иерархически организо-ванными данными могут быть следующие:
- найти указанное дерево БД (например, отдел 310);
- перейти от одного дерева к другому;
- перейти от одной записи к другой внутри дерева (например, от отдела - к пер-вому сотруднику);
- перейти от одной записи к другой в порядке обхода иерархии;
- вставить новую запись в указанную позицию;
- удалить текущую запись.

*Ограничения целостности:*
- Автоматически поддерживается целостность ссылок между предками и потомками.
- Основное правило: никакой потомок не может существовать без своего родителя. Заметим, что аналогичное
- поддержание целостности по ссылкам между записями, не входящими в одну иерархию, не поддерживается.

Преимущества  Недостатки
Эффективное использование памяти компьютера  Громоздкость для обработки информа-ции с достаточно сложными связями
Высокие временные показатели выпол-нения операций над данными  Неуниверсальность
Простота  Доступ к данным производится только через корневое отношение
Преимущества Недостатки
Эффективное использование памяти компьютера
Высокие временные показатели выполнения операций над данными
Простота
Громоздкость для обработки информации
с достаточно сложными связями
Неуниверсальность
Доступ к данным производится только через корневое отношение

* Лекция 3 Модели БД
** Сетевая модель
Сетевая модель является расширением иерархической модели однако в сетевой структуре потомок может иметь любое число предков.
Монипулирование данными:
Создание и изменение записей:
  - Уничтожение записей
  - Поиск конкретной записи
  - Переход от предка к потомку и от потомка к предку
  - Влючить в связь или исключить из связи

Ограничение целостности:
- Поддержание целостности не требуется

Преимущества сетевой модели:
- Возможность эффективной реализации по показателям затрат памяти оперативности (оперативная память)
- Большие возможности по созданию и моделированию различных связей между сущностями реального мира
Недостатки сетевой модели:
- Высокая сложность
- Жёсткость схемы данных
- Сложность для понимания и выполнения обработки информации обычным пользователям

** Реалиционная модель
Общие понятия реалиционного подхода к организации БД
Реалиционная модель данных представляет собой набор отношений изменяющихся во времени.
Основные понятия
[[file:/home/dima/Docs/table.jpeg][Отношения]]

Пример реалиционной модели
[[file:/home/dima/Docs/table2.jpeg][Схема отношений]]
                    Cхема отношений
								   
Сущность это объект любой природы данные о котором хранятся в БД.
Данные о сущностях хранятся в отношениях
Отношения представляют собой думерную таблицу в которой соблюдаются следующие свойства
Свойства отношений:
1) В отношении нет одинаковых кортежей
2) Кортежи не упорядочены
3) Атирибуты не упорядочены
4) Все значения аттрибутов атомарны
*Атрибут* - это свойство характеризующее сущность. Атрибут в схеме это столбец таблицы
*Кортеж* - это строка таблицы
Домен это множество всех возможных значений определенного атрибута
*Схема отношений* - список имен атрибутов
Множество кортежей отношений называют содержимым отношения
*Степень* отношения это количество столбцов таблицы
*Мощность* отношения это количество строк таблицы

** Ключи в реалиционной модели
*Первичный ключ* - это атрибут отношения однозначно индетифицирующий каждый из его кортежей.
Ключ может быть состовным (состоять из нескольких атрибутов).
Если выбранный первичный ключ состоит из минимально необходимого набора атрибутов то говорят, что он является не избыточным.
*Внешний ключ* - это ключ используемый для установления связей между отношениями. Содержит значения первичного ключа другой таблицы.
*Индекс* - это средство ускорения операций поиска записей в таблице и других операций использующих поиск. Таблицу для которой используется индекс называют индексированной.
*Ссылочная целосность* - это необходимое качество реалиционной БД. Заключается в отсутствии в любом ее отношении внешних ключей ссылающихся на несуществоющие кортежи

Пример ссылочной целостности:
[[file:/home/dima/Docs/table3.jpeg][Ссылочная целостность]]

Обязательным хотя и недостаточным условием сохранением ссылочной целостности БД является поддержка транзацкий.
Транзацкции не позволят нарушить ссыллочную целостность. Возможно поддержание ссылочной целостности БД с использованием механизма тригеров
Констистентность данных - это согласованность данных друг с другом, целостность данных а также внутреняя непротиворечивость, то есть множество всех условий,
налагающихся на данные.

* Структура внешней памяти методы организации индексов
Реляционные СУБД обладают рядом особенностей, влияющих на организацию внешней памяти:
Наличие двух уровней системы:
- уровня непосредственного упровления данными во внешней памяти
- языкового уровня
При такой организации подсистема нижнего уровня должна поддерживать во внешней памяти набор базовых структур, конкретная интерпретация которых входит в число функций подсистемы верхнего уровня.
** Реляционные СУБД обладают рядом особенностей, влияющих на организацию внешней памяти:
1) Поддержание отношений-каталогов.
Информация, связанная с именованием объектов базы данных и их конкретными свойствами (например, структура ключа индекса), поддерживается подсистемой языкового уровня. С точки зрения структур внешней памяти отношение-каталог ничем не отличается от обычного отношения базы данных.

2) Регулярность структур данных.
Поскольку основным объектом реляционной модели данных является плоская таблица, главный набор объектов внешней памяти может иметь очень простую регулярную структуру.

3)Поддержка индексов.
Необходимо обеспечить возможность эффективного выполнения операторов языкового уровня как над одним отношением (простые селекция и проекция), так и над несколькими отношениями (например, соединение нескольких отношений). Для этого во внешней памяти должны поддерживаться дополнительные «управляющие» структуры - индексы.

4) Поддержка избыточности хранения данных
Обычно реализуется в виде журнала изменений базы данных.

** Разновидности объектов во внешней памяти базы данных
1) Строки отношений
   Основная часть базы данных, большей частью непосредственно видимая пользователям
2) Управляющие структуры
   индексы, создаваемые по инициативе пользователя или верхнего уровня для повышения эффективности выполнения запросов и обычно автоматически поддерживаемые нижним уровнем системы
3) Журнальная информация
   поддерживаемая для удовлетворения потребности в надежном хранении данных
4) Служебная информация
   поддерживаемая для удовлетворения внутренних потребностей нижнего уровня системы (например, информация о свободной памяти)

** Физическое хранение отношений
Существуют два принципиальных подхода к физическому хранению отношений:
*** Покортежное хранение отношений
- кортеж является единицей физического хранения
- обеспечивает быстрый доступ к целому кортежу
- во внешней памяти дублируются общие значения разных кортежей одного отношения
могут потребоваться лишние обмены с внешней памятью, если нужна часть кортежа
*** Хранение отношений по столбцам
- Eдиницей хранения является столбец отношения с исключенными дубликатами
- тратится меньше внешней памяти, поскольку дубликаты значений не хранятся
- за один обмен с внешней памятью считывается больше полезной информации
- возможность использования значений столбца отношения для оптимизации выполнения операций соединения
- требуются существенные дополнительные действия для сборки целого кортежа (или его части)
** Индексы
- _Назначение_: обеспечение эффективного прямого доступа к кортежу отношения по ключу. Обычно индекс определяется для одного отношения, и ключом является значение атрибута.
- Если ключом индекса является возможный ключ отношения, то индекс должен обладать свойством уникальности, т.е. не содержать дубликатов ключа.
- На практике ситуация выглядит обычно противоположно: при объявлении первичного ключа отношения автоматически заводится уникальный индекс, а единственным способом объявления возможного ключа, отличного от первичного, является явное создание уникального индекса. Это связано с тем, что для проверки сохранения свойства уникальности возможного ключа так или иначе требуется индексная поддержка.

Поскольку при выполнении многих операций языкового уровня требуется сортировка отношений в соответствии со значениями некоторых атрибутов, полезным свойством индекса является обеспечение последовательного просмотра кортежей отношения в диапазоне значений ключа в порядке возрастания или убывания значений ключа.

Одним из способов оптимизации выполнения эквисоединения отношений (наиболее распространенная из числа дорогостоящих операций) является организация так называемых мультииндексов для нескольких отношений, обладающих общими атрибутами. Любой из этих атрибутов (или их набор) может выступать в качестве ключа мультииндекса. Значению ключа сопоставляется набор кортежей всех связанных мультииндексом отношений, значения выделенных атрибутов которых совпадают со значением ключа.

** Методы организации индексов:
*** В-деревья
- Наиболее популярным подходом к организации индексов в БД является использование техники B-деревьев. 
- С точки зрения внешнего логического представления B-дерево - это сбалансированное сильно ветвистое дерево во внешней памяти. Сбалансированность означает, что длина пути от корня дерева к любому его листу одна и та же. Ветвистость дерева - это свойство каждого узла дерева ссылаться но большое число узлов-потомков. 
- С точки зрения физической организации B-дерево представляется как мультисписочная структура страниц внешней памяти, т.е. каждому узлу дерева соответствует блок внешней памяти (страница). Внутренние и листовые страницы обычно имеют разную структуру.
*** Хэширование
- Альтернативным и все более популярным подходом к организации индексов является использование техники хэширования. 
- _Идея_: применение к значению ключа некоторой функции свертки (хэш-функции), вырабатывающей значение меньшего размера. Свертка значения ключа затем используется для доступа к записи. Свертка ключа используется как адрес в таблице, содержащей ключи и записи. 
_Требование к хэш-функции_: равномерное распределение значение свертки. При возникновении коллизий (одна и та же свертка для нескольких значений ключа) образуются цепочки переполнения. Главным ограничением этого метода является фиксированный размер таблицы. Если таблица заполнена слишком сильно или переполнена, то доступ к записи за одно обращение к таблице будет потерян. Расширение таблицы требует ее полной переделки на основе новой хэш-функции (со значением свертки большего размера).

В случае баз данных такие действия являются абсолютно неприемлемыми. Поэтому обычно вводят промежуточные таблицы-справочники, содержащие значения ключей и адреса записей, а сами записи хранятся отдельно. Тогда при переполнении справочника требуется только его переделка, что вызывает меньше накладных расходов.

Чтобы избежать потребности в полной переделки справочников, при их организации часто используют технику B-деревьев с расщеплениями и слияниями. Хэш-функция при этом меняется динамически, в зависимости от глубины B-дерева. Путем дополнительных технических ухищрений удается добиться сохранения порядка записей в соответствии со значениями ключа. В целом методы B-деревьев и хэширования все более сближаются.

** Журнальная информация
_*Журнал*_ обычно представляет собой чисто последовательный файл с записями переменного размера, которые можно просматривать в прямом или обратном порядке. 

Обмены производятся стандартными порциями (страницами) с использованием буфера оперативной памяти. В грамотно организованных системах структура журнальных записей известна только компонентам СУБД, ответственным за журнализацию и восстановление. 

Поскольку содержимое журнала является критичным при восстановлении базы данных после сбоев, к ведению файла журнала предъявляются особые требования по части надежности. В частности, обычно стремятся поддерживать две идентичные копии журнала на разных устройствах внешней памяти.
** Служебная информация
Для корректной работы подсистемы управления данными во внешней памяти необходимо поддерживать информацию, которая используется только этой подсистемой и не видна подсистеме языкового уровня. Набор структур служебной информации зависит от общей организации системы, но обычно требуется поддержание следующих служебных данных:
1) Внутренние каталоги, описывающие физические свойства объектов базы данных (число атрибутов отношения, их размер, описание индексов и т.д.)
2) Описатели свободной и занятой памяти в страницах отношения. Такая информация требуется для нахождения свободного места при занесении кортежа. Отдельно приходится решать задачу поиска свободного места в случаях некластеризованных и кластеризованных отношений
3) Связывание страниц одного отношения.

* Тема 3.1. Особенности архитектуры клиент-сервер
:PROPERTIES:
:CUSTOM_ID: тема-3.1.-особенности-архитектуры-клиент-сервер
:END:
Компоненты сети: - *Рабочая станция* - предназначена непосредственно для
работы пользователя (группы пользователей). Имеет характеристики как у
компьютера. - *Сервер локальных сетей* - должен обладать ресурсами,
соответствующими его функциональному назначению.

*Клиент* - это тот, кто запрашивает услугу у сервера. *Сервер* - это
компонент локальной сети, оказывающий услуги клиентам.

Понятие *сервер базы данных обычно* включает и сервер, и клиент.

Преимущество БД на SQL - унифицированность интерфейса.

* Тема 3.2. Функции и основные возможности языка SQL
:PROPERTIES:
:CUSTOM_ID: тема-3.2.-функции-и-основные-возможности-языка-sql
:END:
** Краткая история и структура SQL
:PROPERTIES:
:CUSTOM_ID: краткая-история-и-структура-sql
:END:
Прототип языка был разработан фирмой IBM в 1974 году и известен под
названием /SEQUEL (Structured English Query Language)/. В настоящее
время известен как SQL.

Этот язык является официально утверждённым стандартом. Относится к
классу непроцедурных языков программирования.

В SQL результатом любой операции над отношениями также является
отношение.

Составные части SQL: 1. *Язык определения данных* (*DDL*) --
предоставляет возможность создания изменения и удаления различных
объектов БД (таблиц, индексов, пользователей и т.д.); 2. *Язык
манипулирования данными* (*DML*) -- предоставляет возможность
добавления, изменения и удаления информации в БД; 3. *Язык для
административных операций* (*DCL* -- *Data Control Language*) --
осуществляет присваивание или отмену прав (привилегий) использовать БД,
таблицы и другие объекты; 4. *Язык контроля транзакций* (*TCL* --
*Transaction Control Language*) -- даёт возможность управлять
транзакциями; 5. *Язык запросов* -- предоставляет возможность выборки из
базы информации из БД.

** Диалект MySQL стандарта SQL
:PROPERTIES:
:CUSTOM_ID: диалект-mysql-стандарта-sql
:END:
*** Типы данных в MySQL
:PROPERTIES:
:CUSTOM_ID: типы-данных-в-mysql
:END:
1. Числовые:
   - *INT* - обычный целочисленный тип. Со знаком: -2,147,483,648 до
     2,147,483,647, Без знака: 0 до 4,294,967,295. Размер в байтах: 4.
   - *TINYINT* - очень маленький целочисленный тип. Со знаком: -128 до
     127, Без знака: 0 до 255. Размер в байтах: 1.
   - *SMALLINT* - маленький целочисленный тип. Со знаком: -32,768 до
     32,767, Без знака: 0 до 65,535. Размер в байтах: 2.
   - *MEDIUMINT* - средний целочисленный тип. Со знаком: -8,388,608 до
     8,388,607, Без знака: 0 до 16,777,215. Размер в байтах: 3.
   - *BIGINT* - большой целочисленный тип. Со знаком:
     -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807, Без знака:
     0 до 18,446,744,073,709,551,615. Размер в байтах: 8.
   - *FLOAT* - число с одинарной точностью. Хранит приближенные значения
     (±1.175494351E-38 до ±3.402823466E+38). Размер в байтах: 4.
   - *DOUBLE* - число с двойной точностью. Более точный формат, чем
     FLOAT (±2.2250738585072014E-308 до ±1.7976931348623157E+308).
     Размер в байтах: 8.
   - *DECIMAL*/*NUMERIC* - точный числовой тип для хранения чисел с
     фиксированной точностью. Диапазон значений зависит от указанных
     параметров (например, DECIMAL(5,2) --- 5 цифр всего, из них 2 после
     запятой). Размер в байтах: переменный (зависит от параметров).
2. Строковые и символьные:
   - *CHAR(n)* - строка фиксированной длины. Если строка короче n, она
     дополняется пробелами. Хранит до 255 символов. Размер в байтах: n.
   - *VARCHAR(n)* - строка переменной длины. Хранит только фактическую
     длину строки. Максимальная длина: до 65,535 символов (зависит от
     кодировки). Размер в байтах: длина строки + 1 или 2 байта (для
     хранения длины).
   - *BINARY(n)* - бинарная строка фиксированной длины. До 255 байт.
     Размер в байтах: n.
   - *VARBINARY(n)* - бинарная строка переменной длины. До 65,535 байт.
     Размер: длина данных + 1 или 2 байта.
   - *BLOB* - Поле для хранения бинарных данных среднего размера. До
     65,535 байт. Размер: длина данных + 2 байта.
   - *TINYBLOB* - Поле для хранения небольших бинарных данных. До 255
     байт. Размер: длина данных + 1 байт.
   - *TEXT* - Текстовое поле среднего размера. До 65,535 символов.
     Размер: длина данных + 2 байта.
   - *TINYTEXT* - Текстовое поле небольшого размера. До 255 символов.
     Размер: длина данных + 1 байт.
3. Дата и время:
   - *DATE* - Хранит только дату. Формат: 'YYYY-MM-DD'. Размер: 3 байта.
   - *TIME* - Хранит только время. Формат: 'HH:MM:SS'. Размер: 3 байта.
   - *DATETIME* - Хранит дату и время вместе. Формат: 'YYYY-MM-DD
     HH:MM:SS'. Размер: 8 байт.
   - *TIMESTAMP* - Хранит дату и время, но автоматически преобразует их
     в UTC при сохранении. Формат: 'YYYY-MM-DD HH:MM:SS'. Размер: 4
     байта.
   - *YEAR* - Хранит год. Формат: YYYY (например, 2023). Размер: 1 байт.

*** Создание БД и создание таблиц
:PROPERTIES:
:CUSTOM_ID: создание-бд-и-создание-таблиц
:END:
Команды DDL: 1. *CREATE* - создание объектов БД. 2. *ALTER* - изменение
объектов БД. 3. *DROP* - удаление объектов БД.

**** Использование CREATE
:PROPERTIES:
:CUSTOM_ID: использование-create
:END:
Создание БД:

#+begin_src
CREATE DATABASE db_name;
#+end_src

Начало работы с существующей БД:

#+begin_src
USE db_name;
#+end_src

Пример таблицы =TABLE person=:

| column | data_type     |
|--------+---------------|
| * id   | =INT=         |
| name   | =VARCHAR(50)= |
| phone  | =VARCHAR(50)= |

#+begin_src
CREATE DATABASE test_bd;
CREATE TABLE Person {
    id BIGINT NOT NULL UNSIGNED UNIQUE AUTO_INCREMENT,
    id SERIAL, -- Замена строки выше + установка PK
    name VARCHAR(50) NOT NULL,
    phone VARCHAR(50) NOT NULL,
    PRIMARY KEY (id)
};
#+end_src

Свойство столбца: * *AUTO_INCREMENT* - позволяет указать, что значение
столбца будет автоматически увеличиваться при добавлении новой строки.
Работает только для целочисленных типов: =INT=, =TINYINT=, =SMALLINT=,
=MEDIUMINT=, =BIGINT=; * *NOT NULL* - обозначает, что столбец не может
принимать значение =NULL=; * *DEFAULT* - определяет значение по
умолчанию (пример для полей телефона: =DEFAULT “111-11-11”=); *
*CHECK* - задаёт ограничение для диапазона значений, которые могут
храниться в столбце (пример для полей возраста:
=age int CHECK(age > 0 AND age < 150)=; * *UNSIGNED* - значение больше
нуля (делает поле беззнаковым); * *UNIQUE* - значение в данном поле
будет уникальным; * *SERIAL* - псевдоним группы свойств =UNSIGNED=,
=UNIQUE=, =AUTO_INCREMENT=, =NOT NULL=, =BIGINT=.

Первичный ключ можно определить отдельной строкой *PRIMARY KEY (id)* или
у самого поля *id SERIAL PRIMARY KEY*.

Добавление *FOREIGN KEY*. Предположим, что есть таблица =City= с PK
=id=, тогда:

#+begin_src
CREATE TABLE Person (
    id SERIAL,
    name VARCHAR(50) NOT NULL,
    phone VARCHAR(50) NOT NULL
    cityId_City INT UNSIGNED NOT NULL,
    FOREIGN KEY (cityId_City) REFERENCES City(id)
);
#+end_src

Механизм поддержания ссылочной целостности:

Ключевые слова *ON UPDATE* и *ON DELETE* используются в SQL для
определения поведения внешнего ключа =FOREIGN KEY= при изменении или
удалении связанной записи в целевой таблице. Они позволяют
контролировать, что произойдет с зависимыми данными, если первичная
запись изменится или будет удалена. * *ON UPDATE* - определяет, что
произойдет с зависимыми записями в текущей таблице, если значение
первичного ключа в зависимой таблице будет изменено; * *ON DELETE* -
определяет, что произойдет с зависимыми записями в текущей таблице, если
запись в зависимой таблице удаляется.

#+begin_src
CREATE TABLE Person (
    id SERIAL,
    name VARCHAR(50) NOT NULL,
    phone VARCHAR(50) NOT NULL,
    cityId_City INT UNSIGNED NOT NULL,
    FOREIGN KEY (cityId_City)
        REFERENCES City(id)
        ON UPDATE ...
        ON DELETE ...
);
#+end_src

Вместо =...= может быть: * *CASCADE* - каскадное обновление / удаление
строк дочерней таблицы; * *SET NULL* - обнуление значения внешнего ключа
в соответствующих строках дочерней таблицы; * *RESTRICT* - запрет
обновления / удаления строк родительской таблицы при наличии ссылающихся
строк дочерней таблицы.

**** Использование ALTER
:PROPERTIES:
:CUSTOM_ID: использование-alter
:END:
1. Переименовать таблицу:

#+begin_src
ALTER TABLE test_table RENAME Person;
#+end_src

2. [@2] Изменить тип столбца:

#+begin_src
ALTER TABLE Person MODIFY name VARCHAR(30);
#+end_src

3. [@3] Изменить тип и имя столбца:

#+begin_src
ALTER TABLE Person CHANGE name Name VARCHAR(50);
#+end_src

4. [@4] Добавление столбца:

#+begin_src
ALTER TABLE Person ADD Name VARCHAR(50) FIRST;
ALTER TABLE Person ADD City VARCHAR(50) AFTER Name;
#+end_src

- =AFTER= - имя предшествующего столбца;
- =FIRST= - добавить как первый столбец.

5. [@5] Добавление первичного ключа:

#+begin_src
ALTER TABLE Person
    ADD CONSTRAINT id -- CONSTRAINT - ограничения PK
    PRIMARY KEY (id);
#+end_src

6. [@6] Добавление внешнего ключа:

#+begin_src
ALTER TABLE Person
    ADD CONSTRAINT fk_city
    FOREIGN KEY (city_id) REFERENCES City(city_id)
#+end_src

**** Использование DROP
:PROPERTIES:
:CUSTOM_ID: использование-drop
:END:
Удаление таблицы:

#+begin_src
DROP TABLE Person;
#+end_src

* Язык манипулирования данными (Data Manipulation Language, DML)
:PROPERTIES:
:CUSTOM_ID: язык-манипулирования-данными-data-manipulation-language-dml
:END:
** Подразделы SQL
:PROPERTIES:
:CUSTOM_ID: подразделы-sql
:END:
| Commands                 | Language                               |
|--------------------------+----------------------------------------|
| *SELECT*                 | Язык запросов (Queries)                |
| *CREATE**ALTER**DROP*    | Язык определенияданных (DDL)           |
| *INSERT**UPDATE**DELETE* | Язык манипулированияданными (DML)      |
| *GRANT**REVOKE*          | Язык управления доступомк данным (DCL) |
| *COMMIT**ROLLBACK*       | Язык управлениятранзакциями (TCL)      |

** DML
:PROPERTIES:
:CUSTOM_ID: dml
:END:
Команды DML для работы с таблицами: * *INSERT* - вставка строк в
таблицу. * *UPDATE* - изменение значений полей. * *DELETE* - изменение
значений полей.

*** Ввод значений в таблицы
:PROPERTIES:
:CUSTOM_ID: ввод-значений-в-таблицы
:END:
Форма оператора INSERT:

#+begin_src sql
INSERT INTO tableName (list_of_columns)
VALUES (list_of_values);
#+end_src

Данные вводятся в таблицу в порядке их перечисления. Пример ввода строки
в таблицу Client:

#+begin_src sql
INSERT INTO  Client (id, Surname, Name, Age, Phone, Address)
VALUES (6, 'Иванов', 'Степан', 22, '293387765', 'Могилев');
#+end_src

Список столбцов может быть опущен. Пример ввода строки в таблицу Client:

#+begin_src sql
INSERT INTO  Client
VALUES (6, 'Иванов', 'Степан', 22, '293387765', 'Могилев');
#+end_src

Для определения порядка столбцов в таблице используйте: *DESCRIBE
table_name*.

*** Ввод неопределенных значений
:PROPERTIES:
:CUSTOM_ID: ввод-неопределенных-значений
:END:
*NULL* может явно вводиться в поле так же, как обычное значение:

#+begin_src sql
INSERT INTO  Client (id, Surname, Name, Age, Phone, Address)
VALUES (6, 'Иванов’, 'Степан', 22, NULL,'Могилев');
#+end_src

Поле в таком случае не должно иметь ограничения (*NOT NULL*).

*** Ввод значений по умолчанию
:PROPERTIES:
:CUSTOM_ID: ввод-значений-по-умолчанию
:END:
Можно вводить в поле значение по умолчанию:

#+begin_src sql
INSERT INTO Client (id, Surname, Name, Age, Phone, Address)
VALUES (6, 'Иванов’, 'Степан', 22, NULL, DEFAULT);
#+end_src

Перед вставкой для поля должно быть установлено значение по умолчанию
(*DEFAULT*).

*** Ввод неопределенных значений (2)
:PROPERTIES:
:CUSTOM_ID: ввод-неопределенных-значений-2
:END:
*Неявный метод:* Если столбец не указан в списке столбцов -- его
значение для записи будет *NULL* (или *DEFAULT*). В примере не указан
столбец Phone и Address :

#+begin_src sql
INSERT INTO Client (id, Surname, Name, Age)
VALUES (6, 'Иванов’, 'Степан', 22);
#+end_src

Поле не должно иметь ограничения (*NOT NULL*).

*** Значения по умолчанию и NULL
:PROPERTIES:
:CUSTOM_ID: значения-по-умолчанию-и-null
:END:
Оператор *INSERT*, не содержащий значения для столбца * вставит *NULL*,
если столбец не содержит ограничения NOT NULL и предложения DEFAULT; *
вставит *значение по умолчанию*, если столбец содержит предложение
DEFAULT; * выдаст *ошибку*, если столбец содержит ограничение NOT NULL,
а значение по умолчанию не указано.

*** Вставка даты
:PROPERTIES:
:CUSTOM_ID: вставка-даты
:END:
При вставке даты можно использовать: * SYSDATE -- текущая дата; *
TO_DATE(...) -- конкретная дата.

*** Вставка результатов запроса
:PROPERTIES:
:CUSTOM_ID: вставка-результатов-запроса
:END:
Оператор *INSERT* можно использовать для вставки результатов запроса:

#+begin_src sql
INSERT INTO table_name (list_of_columns) query;
#+end_src

Пример перемещения значений из одной таблицы в другую:

#+begin_src sql
INSERT INTO Londonstaff
SELECT * FROM Salespeople
WHERE city = 'London';
#+end_src

*** Вставка сразу нескольких записей
:PROPERTIES:
:CUSTOM_ID: вставка-сразу-нескольких-записей
:END:
Для вставки нескольких записей в одну таблицу используйте *INSERT ALL*:

#+begin_src sql
INSERT ALL
INTO table_name (list_of_columns)
VALUES (list_of_values);
INTO table_name (list_of_columns)
VALUES (list_of_values);
INTO table_name (list_of_columns)
VALUES (list_of_values);
...
#+end_src

*** Создание новой таблицы
:PROPERTIES:
:CUSTOM_ID: создание-новой-таблицы
:END:
Создать новую таблицу и скопировать все данные из старой:

#+begin_src sql
CREATE TABLE new_table AS SELECT * FROM old_table;
#+end_src

*** Изменение значений полей
:PROPERTIES:
:CUSTOM_ID: изменение-значений-полей
:END:
Изменение всех или некоторых значений в существующих строках выполняется
с помощью оператора *UPDATE*:

#+begin_src sql
UPDATE имя таблицы
SET { имя столбца = { выражение
                    | NULL
                    | DEFAULT }
    }.,..
[ { WHERE предикат } ];
#+end_src

Пример: Увеличить зарплату всем сотрудникам на 10%:

#+begin_src sql
UPDATE employees
SET salary = salary * 1.1;
#+end_src

Пример: Увеличить зарплату на 1000 только сотрудникам из отдела IT:

#+begin_src sql
UPDATE employees
SET salary = salary + 1000
WHERE department = 'IT';
#+end_src

Пример обновления значений поля для всех строк таблицы Products:

#+begin_src sql
UPDATE Products
SET qty = 200;
#+end_src

Пример обновления значений поля для отдельных строк таблицы Products:

#+begin_src sql
UPDATE Products
SET qty = 200
WHERE id = 5;
#+end_src

Пример обновления значений группы полей для отдельной строки таблицы
Client:

#+begin_src sql
UPDATE Client
SET Name = 'Олег',
    Address  = 'Минск',
    Age  = 27
WHERE id = 5;
#+end_src

Не разрешается обновлять несколько таблиц в одном операторе UPDATE.

В предложении *SET* оператора *UPDATE* разрешается применять выражения:

#+begin_src sql
UPDATE Product
SET qty = qty * 2
WHERE name_prod = 'Молоко';
#+end_src

Разрешается обновлять до NULL-значений или значений по умолчанию:

#+begin_src sql
UPDATE Client
SET Phone = NULL,
    Address = DEFAULT
WHERE id = 5;
#+end_src

*** Изменение значений полей с подзапросами
:PROPERTIES:
:CUSTOM_ID: изменение-значений-полей-с-подзапросами
:END:
Обновление с помощью многостолбцового подзапроса:

#+begin_src sql
UPDATE Product
SET (price, qty) =
    (SELECT price, qty
     FROM Product 
     WHERE id = 1)
WHERE id = 6;
#+end_src

Обновление строк таблицы на основе значений из других таблиц:

#+begin_src sql
UPDATE Product
SET  qty =
     (SELECT qty
      FROM Orders
      WHERE id = 2)
WHERE id =
     (SELECT id_Product
      FROM Orders
      WHERE id = 2);
#+end_src

*** Контроль целостности при изменении
:PROPERTIES:
:CUSTOM_ID: контроль-целостности-при-изменении
:END:
Если вы пытаетесь обновить запись и новое значение столбца противоречит
*ограничению*, выдается сообщение об ошибке:

#+begin_src sql
UPDATE Orders
SET  id_Product = 9  -- ОШИБКА
WHERE id_Product = 2;
#+end_src

* Манипулирование данными
:PROPERTIES:
:CUSTOM_ID: тема.-манипулирование-данными
:END:
** Язык манипулирования данными (DML)
:PROPERTIES:
:CUSTOM_ID: язык-манипулирования-данными-dml
:END:
Добавление новой информации:

#+begin_src sql
INSERT
#+end_src

Обновление информации:

#+begin_src sql
UPDATE
#+end_src

Удаление информации:

#+begin_src sql
DELETE
#+end_src

Форма оператора INSERT: INSERT INTO table_name (list_of_columns) VALUES
(list_of_values) Данные вводятся в порядке их перечисления. Пример:
INSERT INTO Client (id, Surname, Name, Age, Phone, Address) VALUES (6,
'Иванов', 'Степан', 22, '45798167327', 'Могилев');

** Список столбцов может быть опущен
:PROPERTIES:
:CUSTOM_ID: список-столбцов-может-быть-опущен
:END:
Пример ввода строки в таблицу Client:

#+begin_src sql
INSERT INTO Client VALUES (6, 'Иванов', ...);
#+end_src

Для определения порядка столбцов используйте:

#+begin_src sql
DESCRIBE
#+end_sql

*** Ввод неопределённых значений
:PROPERTIES:
:CUSTOM_ID: ввод-неопределённых-значений
:END:
NULL может явно вводиться в поле так же, как обычное значение ...

*** Ввод значений по умолчанию
:PROPERTIES:
:CUSTOM_ID: ввод-значений-по-умолчанию-1
:END:
Можно вводить в поле

**** Неявный метод:
:PROPERTIES:
:CUSTOM_ID: неявный-метод
:END:
Если столбец не указан в списке столбцов - его значение для записи будет
*NULL* (или *DEFAULT*) В примере не указан столбец *Phone* и *Address*:

#+begin_src sql
INSERT INTO Client (id, Surname, Name, Age)
...
#+end_src

**** Значения по умолчанию и NULL
:PROPERTIES:
:CUSTOM_ID: значения-по-умолчанию-и-null-1
:END:
Оператор INSERT

**** Вставка даты
:PROPERTIES:
:CUSTOM_ID: вставка-даты-1
:END:
При вставке даты можно использовать: Текущая дата

#+begin_src sql
SYSDATE
#+end_src

**** Вставка результатов запроса
:PROPERTIES:
:CUSTOM_ID: вставка-результатов-запроса-1
:END:
Оператор INSERT можно использовать для вставки результатов запроса:

#+begin_src sql
...
#+end_src

Вставка нескольких строк в одной команде:

#+begin_src sql
INSERT INTO Client
VALUES (...),
(...),
(...);
#+end_src

*** Изменение значений полей
:PROPERTIES:
:CUSTOM_ID: изменение-значений-полей-1
:END:
Изменение всех или некоторых значений в /существующих/ строках
выполняется с помощью оператора UPDATE:

#+begin_src sql
UPDATE имя_таблицы
SET {имя_столбца = {выражение
                    | NULL
                    | DEFAULT }},
...,
[ { WHERE ghtlbrfn }]
};
#+end_src

Пример обновления значений /группы полей/ для отдельной строки таблицы
Client:

#+begin_src sql
UPDATE Client
SET Name = 'Олег',
    Address = 'Минкс',
    Age = 27
WHERE id = 5;
#+end_src

В предложении SET оператора UPDATE разрешается применять выражения:

#+begin_src sql
UPDATE Product
...
#+end_src

Обновление с помощью многостолбцового подзапроса: ...

Обновление строк ...

Если вы пытаетесь обновить запись...

*** Удаление строк из таблицы
:PROPERTIES:
:CUSTOM_ID: удаление-строк-из-таблицы
:END:
#+begin_src sql
DELETE FROM имя_таблицы
...
#+end_src

Очистить все строки в таблице без логов и возможности ROLLBACK:

#+begin_src sql
TRUNCATE name_databse;
#+end_src

** ЗАПРОСЫ ВЫБОРКИ ДАННЫХ
:PROPERTIES:
:CUSTOM_ID: запросы-выборки-данных
:END:
Выбрать всё из таблицы:

#+begin_src sql
SELECT * FROM Client;
#+end_src

Выбрать всё без повторений:

#+begin_src sql
SELECT DISTINCT Name FROM Client;
#+end_src

*LIMIT* - извлечь определённое количество строк:

#+begin_src sql
SELECT * FROM Product LIMIT 3; -- Сколько строк отобразить (3 первые)
#+end_src

#+begin_src sql
SELECT * FROM Product LIMIT 2, 3; -- Пропустить 2, отобразить 3 следующие
#+end_src

*** Сортировка данных
:PROPERTIES:
:CUSTOM_ID: сортировка-данных
:END:
*ORDER BY* - сортирует при выводе, но не меняет их физическое
расположение. Добавляется в конец запроса:

#+begin_src
#+end_src

Критерии сортировки могут расширятся с помощью *DESC* и *ASC*.

Правила сортировки: 1. Сначала записи сортируются по полю, указанному
первым в списке. 2. Если для некоторых записей значения этого поля
одинаковы, то записи далее сортируются по полю, указанному вторым в
списке. 3. Если для некоторых записей значения и этого поля одинаковы,
то записи далее сортируются по полю, указанному третьим в списке. 4. И
т.д.

По умолчанию записи сортируются по возрастанию (*ASC*). Если нужно по
убыванию, указывается *DESC*.

Примеры:

#+begin_src
SELECT * FROM Client ORDER BY Surname;
#+end_src

#+begin_src
SELECT name_prod, price FROM Product ORDR BY name_prod DESC;
#+end_src

*** Фильтрация данных
:PROPERTIES:
:CUSTOM_ID: фильтрация-данных
:END:
Для фильтрации используется ключевое слово *WHERE* (Ставится между
ключевыми словами FROM и ORDER BY). Доступные операторы: *=*, *<>* или
*!=*, *<*, *>*, *<=*, *>=*.

Примеры:

#+begin_src
SELECT * FROM Client WHERE Name="Иван";

SELECT * FROM Client WHERE Name<>"Иван";
#+end_src

Строковые величины являются частью критериев и заключаются в кавычке как
выше. Числа без кавычек.

Логические операторы: *OR*, *AND*, *NOT*:

#+begin_src
SELECT * FROM Client WHERE Name="ИВан" OR Name="Алексей";

SELECT id FROM Product WHERE name_prod="Молоко" AND price=1.8;

SELECT id FROM Product WHERE NOT id=3; -- Аналогичен id<>3
#+end_src

Логические операторы можно комбинировать:

#+begin_src
SELECT * FROM Client WHERE NOT (Name="Иван" OR Name="Алексей");
#+end_src

Оператор *IN* (равен любому из списка) Получить всю информацию о
Заказах, где id равен 3, 5 или 7:

#+begin_src
SELECT * FROM Orders WHERE id IN (3,5,7);
#+end_src

Оператор *NOT IN* (не равен ни одному из списка):

#+begin_src
SELECT * FROM Orders WHERE id NOT IN (1,4);
#+end_src

Оператор *BETWEEN* (вхождение значения поля в заданный интервал):

#+begin_src
SELECT * FROM Product WHERE price BETWEEN 2 AND 3; -- Значения 2 и 3 входят в промежуток
#+end_src

Оператор *LIKE* (применим только к символьным полям). Используется с:
*%* - любое количество символов; _ (*нижнее подчёркивание*) - любой 1
символ.

#+begin_src
SELECT * FROM Product WHERE name_prod LIKE 'М%' -- Молоко, Масло и т.д.
#+end_src

Оператор *REGEXP* (позволяет задать регулярное значение). Используется с
символами: * *^* - указывает на начало строки; * *$* - указывает на
конец строки; * *.* - соответствует любому одиночному символу; *
*[символы]* - соответствует любому одиночному символу из скобок; *
*[начальный_символ-конечный_символ]* - соответствует любому одиночному
символу из диапазона символов; * *|* - отделяет 2 шаблона строки, и
значение должно соответствовать одному из этих шаблонов.

Примеры:

#+begin_src
SELECT * FROM Product WHERE name_prod REGEXP 'оло|оро';
SELECT * FROM Product WHERE name_prod REGEXP 'р$';
#+end_src

Оператор *IS NULL* (*IS NOT NULL*) (столбцы имеют / не имеют значение
NULL)

#+begin_src
SELECT * FROM Product WHERE qty IS NULL;
SELECT * FROM Product WHERE qty IS NOT NULL;
#+end_src

**** Задание связей между таблицами
:PROPERTIES:
:CUSTOM_ID: задание-связей-между-таблицами
:END:
Чтобы связать 2 таблицы и получить из них данные, используется ключевое
слово *WHERE*:

#+begin_src
SELECT Orders.Order_date, Client.Surname, Client.Name
FROM Orders, Client
WHERE Orders.id_Client=Client.id; -- Если не указать, то получится декартово произведение
#+end_src

Ещё пример (3 таблицы):

#+begin_src
SELECT Orders.Order_date, Product.name_prod, Client.Name
FROM Orders, Client, Product
WHERE Orders.id_Client=Client.id
AND Orders.id_Product=Product.id;
#+end_src

#+begin_src
SELECT Orders.Order_date, Product.name_prod, Product.price
FROM Orders, Product
WHERE Orders.id_Product=Product.id
AND Product.price > 2;
#+end_src

Псевдонимы полей (алиасы):

#+begin_src
SELECT ... <имя поля> AS <псевдоним>, ...
#+end_src

Пример:

#+begin_src
SELECT o.Order_date, p.name_prod, p.price*o.qty AS Total_Sum
FROM Orders AS o, Product AS p
WHERE o.id_Products=p.id
ORDER BY Total_Sum;
#+end_src

*** Агрегатные функции SQL и группировка
:PROPERTIES:
:CUSTOM_ID: агрегатные-функции-sql-и-группировка
:END:
*Группировка* - это объединение записей в группу по какому-либо
критерию, называемому /критерием группировки/. Выполняется с помощью
ключевого слова *GROUP BY*, после которого записываются критерии
группировки. GROUP BY ставится перед ключевым словом ORDER BY.

*Агрегатные функции* - это функции, которые выполняются над набором
строк.

Поля, по которым ведётся группировка, должны быть первыми...

Агрегатные функции в языке SQL: *COUNT*(n) - количество записей;
*SUM*(n) - сумма значений поля всех записей группы; *AVG*(n) - среднее
значение поля всех записей группы; *MIN*(n) - минимальное из значений
поля во всех записях группы; *MAX*(n) - максимальное из значений поля во
всех записях группы.

Пример:

#+begin_src
SELECT Client.id, Client.Name,
COUNT(Orders.id_Client) AS Orders_count
FROM Client, Orders
WHERE Orders.id_Client=Client.id
GROUP BY Orders.id_Client
ORDER BY Orders_count;
#+end_src

Оператор *HAVING* (фильтрация групп). Аналогичен оператору WHERE
(который применяется для фильтрации строк).

#+begin_src
SELECT Client.Address, COUNT(*) AS ClientCount FROM Client
GROUP BY Client.Address HAVING COUNT(*) > 1;
#+end_src

Задания:

#+begin_src
-- Вывести фамилии всех клиентов
SELECT Surname FROM Client;
-- Вывести названия всех продуктов в отсортированном виде
SELECT name_prod FROM Product ORDER BY name_prod;
-- Вывести названия и стоимость топ-3 самых дорогих продуктов
SELECT name_prod, price FROM Productк
ORDER BY price DESC
LIMIT 3;
-- Вывести дату последнего заказа
SELECT Order_date FROM Orders
ORDER BY Order_date
LIMIT 1;
-- Вывести все имена на букву «И» без повторений
SELECT Name FROM Client
WHERE Name LIKE 'И%';
-- Для каждого продукта вывести количество проданного товара
SELECT p.name_prod, SUM(o.qty) FROM Product p, Orders o
WHERE o.id=p.id_product; -- ?
-- Вывести количество клиентов
SELECT COUNT(*) FROM Client;
-- Для каждого заказа вывести его стоимость

-- Вывести все заказы за 2012 год
#+end_src

** Администрирование БД
:PROPERTIES:
:CUSTOM_ID: администрирование-бд
:END:
DDL: *CREATE USER* - добавление учётной записи пользователя. *DROP
USER* - удаление учётной записи пользователя.

DML: *GRANT* - предоставление прав. *REVOKE* - отзыв прав.

*** Команда CREATE USER
:PROPERTIES:
:CUSTOM_ID: команда-create-user
:END:
Синтаксис:

#+begin_src sql
CREATE USER 'имя_пользователя'@'хост' IDENTIFIED BY 'пароль';
#+end_src

Кроме имени пользователя, здесь нужно задать хост, с которого может
авторизоваться этот пользователь. Здесь может быть *доменное имя*,
*IP-адрес*, *адрес подсети* или знак "*%*", который означает все
возможные хосты. Это очень удобно, потому что вы можете создать
пользователя, к которому можно будет подключится только локально или
настроить отдельно права для локального или удалённого пользователя.

Пример:

#+begin_src sql
CREATE USER 'test_user'@'localhost' IDENTIFIED BY '1234567890';
#+end_src

Просмотр существующих пользователей:

#+begin_src sql
SELECT User, Host FROM mysql.user;
#+end_src

** Команда GRANT
:PROPERTIES:
:CUSTOM_ID: команда-grant
:END:
Синтаксис:

#+begin_src sql
•GRANT привилегии ON база_данных . таблица TO 'имя_пользователя'@'хост’;
#+end_src

Здесь можем дать определённые привилегии для определённого пользователя
к базе данных или таблице. Если нужно дать права для всех баз данных или
таблиц, используйте вместо названия *звездочку* - *

Привилегии пользователя: * *ALL PRIVILEGES* - все, кроме GRANT; *
*USAGE PRIVILEGES* - никаких привилегий; * *SELECT* - делать выборки из
таблиц; * *INSERT* - вставлять данные в таблицу; * *UPDATE* - обновлять
данные в таблице; * *DELETE* - удалять данные из таблицы; * *FILE* -
разрешает читать файлы на сервере; * *CREATE* - создавать таблицы или
базы данных; * *ALTER* - изменять структуру таблиц; * *INDEX* -
создавать индексы для таблиц; * *DROP* - удалять таблицы; * *EVENT* -
обработка событий; * *TRIGGER* - создание триггеров.

Привилегии администратора БД: * *GRANT* - изменять права пользователей;
* *SUPER* - суперпользователь; * *PROCESS* - получение информации о
состоянии MySQL; * *RELOAD* - позволяет перезагружать таблицы
привилегий; * *SHUTDOWN* - позволяет отключать или перезапускать базу
данных; * *SHOW DATABASES* - просмотр списка баз данных; * *LOCK
TABLES* - блокирование таблиц при использовании SELECT; * *REFERENCES* -
создание внешних ключей для связывания таблиц; * *CREATE USER* -
создание пользователей.

/Пример./ Чтобы дать права пользователю MySQL на обновление и добавление
записей для базы данных test_database, выполним:

#+begin_src sql
GRANT SELECT, UPDATE, INSERT ON test_database . * TO 'test_user'@'localhost';
#+end_src

Дальше дадим этому же пользователю все права над этой базой данных:

#+begin_src sql
GRANT ALL PRIVILEGES ON test_database . * TO 'test_user'@'localhost';
#+end_src

Теперь посмотрим привилегии нашего пользователя:

#+begin_src sql
SHOW GRANTS FOR 'test_user'@'localhost';
#+end_src

После обновления прав пользователя необходимо обновить таблицу прав
пользователей MySQL  в памяти. Для этого выполните:

#+begin_src sql
FLUSH PRIVILEGES;
#+end_src

*** Команда REVOKE
:PROPERTIES:
:CUSTOM_ID: команда-revoke
:END:
Чтобы отозвать права у пользователя MySQL, используйте команду *REVOKE*
вместо GRANT.  Синтаксис команды REVOKE:

#+begin_src sql
REVOKE привилегии ON база_данных . таблица FROM 'имя_пользователя'@'хост’;
#+end_src

Например, заберём все права на базу данных test_database у нашего
пользователя:

#+begin_src sql
REVOKE ALL PRIVILEGES ON test_db . * FROM 'test_user'@'localhost';
#+end_src

*** Команда DROP USER
:PROPERTIES:
:CUSTOM_ID: команда-drop-user
:END:
Чтобы удалить пользователя, используют команду DROP USER. Синтаксис
команды DROP USER:

#+begin_src sql
DROP USER  'имя_пользователя'@'хост’;
#+end_src

*** Создание суперпользователя
:PROPERTIES:
:CUSTOM_ID: создание-суперпользователя
:END:
Если вам необходимо создать пользователя со всеми правами MySQL на
замену для root, то можно использовать такую конструкцию:

#+begin_src sql
GRANT ALL PRIVILEGES ON *.* TO 'test_user'@'localhost';
#+end_src

Даём все привилегии для пользователя test_user над всеми базами данными
и всеми таблицами. Но наш пользователь не сможет давать права другим
пользователям. Чтобы это исправить, нужно дать ему привилегию GRANT, а
для этого используется такая команда:

#+begin_src sql
GRANT ALL PRIVILEGES ON *.* TO 'test_user'@'localhost' WITH GRANT OPTION;
#+end_src

Теперь этот пользователь является суперпользователем для MySQL и,
авторизовавшись от его имени, вы можете делать всё то же самое, что и с 
помощью root.
